\documentclass{beamer}
\usepackage[english,russian]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{hyperref}
\usetheme{Warsaw}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{tikz}
\usetikzlibrary{graphs}
\usepackage{algpseudocode}

\lstset{
    frame=tb,
    tabsize=4,
    showstringspaces=false,
    numbers=left,
    commentstyle=\color{green},
    keywordstyle=\color{blue},
    stringstyle=\color{red},
    emph={baz},
    emphstyle=\textbf
}

\begin{document}

\title{Задачи разрешимости логических формул и приложения\newline Лекция 4. SMT решатель. Davis–Putnam–Logemann–Loveland(Theory) фреймворк.}
\author{Роман Холин}
\institute{Московский государственный университет}
\date{Москва, 2022}

\begin{frame}
\includegraphics[scale=0.5]{../decision-procedure.png}
\end{frame}

\frame{\titlepage}

\begin{frame}{SMT решатель}
\begin{itemize}
\item Что, если нам хочется задавать более сложные вопросы решателю? Например, разрешима ли такая формула:
$(x = 4) \wedge ((y = 7) \vee (x = y))$
\item Или такая: $(x + y = 3) \wedge (y - z = 7) \wedge (z * 2 = 4)$
\item Или такая: $(lenght(s) = 3) \wedge (s[0] = $'a'$) \wedge (s[1] = $'b'$) \wedge (s[2] = $'c'$)$
\end{itemize}
\end{frame}

\begin{frame}{SMT решатель}
\begin{itemize}
\item Что, если нам хочется задавать более сложные вопросы решателю? Например, разрешима ли такая формула:
$(x = 4) \wedge ((y = 7) \vee (x = y))$
\item Или такая: $(x + y = 3) \wedge (y - z = 7) \wedge (z * 2 = 4)$
\item Или такая: $(lenght(s) = 3) \wedge (s[0] = $'a'$) \wedge (s[1] = $'b'$) \wedge (s[2] = $'c'$)$
\end{itemize}
Пропозиционной логики для этого не достаточно. Для описания таких систем используется логика первого порядки и теории.
\begin{itemize}
\item равенства и неинтерпритируемых функций
\item линейной арифметики
\item векторы битов
\item массивов
\end{itemize}
\end{frame}

\begin{frame}{Теория первого порядка}
\begin{itemize}
\item Сигнатура $\Sigma = (R, F, C, \rho)$\newline
$R$ - множество символов для отношений (предикатов)\newline
$F$ - множество функциональных символов\newline
$C$ - множество констант\newline
Функция $\rho$, сопоставляющая элементам $R$ и $F$ их арность
\item Переменные
\item Логические операции: $\vee, \wedge, \rightarrow, \lnot$
\item Кванторы: $\forall, \exists$
\item Скобки, запятые
\end{itemize}
\end{frame}

\begin{frame}{Теория первого порядка}
\begin{itemize}
\item Терм - функциональный символ, либо $f(t_1, \dots, t_{\rho (f)})$, где $f$ - символ арности $\rho (f)$, $t_i$ - термы
\item Атом - $p(t_1, \dots t_{\rho (p)})$, где $p$ - предикатный символ арности $\rho (p)$, $t_i$ - термы
\item Формула - либо атом, либо $\lnot f_1$, $f_1 \vee f_2$, $f_1 \wedge f_2$, $f_1 \rightarrow f_2$, $\forall x f_1$,
$\exists x f_1$, где $f_1$ и $f_2$ - формулы
\end{itemize}
\end{frame}

\begin{frame}{Теория первого порядка}
\begin{itemize}
\item Задать модель:\newline
задать множество $D$ - домен\newline
задать функцию $\sigma$, т.ч. каждому предикатному символу сопоставляет предикат, функциональному символу сопоставляет функцию,
а константам сопоставлет элемент из $D$
\end{itemize}
\end{frame}

\begin{frame}{Теория первого порядка}
\begin{itemize}
\item Задать модель:\newline
задать множество $D$ - домен\newline
задать функцию $\sigma$, т.ч. каждому предикатному и функциональному символу сопоставить предикат и функцию
\item Пусть $s$ - функция, которая сопоставляет каждой переменной некоторое значение из $D$
\item Интерпретация формул относительно функции $s$ - индуктивно вычислить формулу.
\end{itemize}
\end{frame}

\begin{frame}{Раскраска графа}
\includegraphics[scale=0.1]{graph-coloring.svg.png}
Имеется граф $G = (V, E)$. Можно ли его вершини расскрасить в $k$ цветов так, чтобы никакие соседние вершины не были раскрашены
в один и тот же цвет?
\end{frame}

\begin{frame}{Раскраска графа}
\includegraphics[scale=0.1]{graph-coloring.svg.png}
Имеется граф $G = (V, E)$. Можно ли его вершини расскрасить в $k$ цветов так, чтобы никакие соседние вершины не были раскрашены
в один и тот же цвет?\newline
\begin{itemize}
\item $x_i$ - целые
\item $1 \le x_i \le c$
\item $x_i \neq x_j$ для $(x_i, x_j) \in E$
\end{itemize}
\end{frame}

\begin{frame}{Эквивалентность программ}
Программа a:\newline
int i, out\_a = in;\newline
for (int i = 0; i < 2; ++i) out\_a = out\_a * inn;\newline
return out\_a;\newline
Программа b:\newline
int out\_b = (in * in) * in;\newline
return out\_b;
\end{frame}

\begin{frame}{Эквивалентность программ}
Программа a:\newline
int i, out\_a = in;\newline
for (int i = 0; i < 2; ++i) out\_a = out\_a * in;\newline
return out\_a;\newline
Программа b:\newline
int out\_b = (in * in) * in;\newline
return out\_b;\newline
$\phi_a := (out\_a_0 = in\_a_0) \wedge (out\_a_1 = out\_a_0 * in\_a_0) \wedge (out\_a_2 = out\_a_1 * in\_a_0)$\newline
$\phi_b := out\_b_0 = (in\_b_0 * in\_b_0) * in\_b_0$\newline
\end{frame}

\begin{frame}{Эквивалентность программ}
Программа a:\newline
int i, out\_a = in;\newline
for (int i = 0; i < 2; ++i) out\_a = out\_a * in;\newline
return out\_a;\newline
Программа b:\newline
int out\_b = (in * in) * in;\newline
return out\_b;\newline
$\phi_a := (out\_a_0 = in\_a_0) \wedge (out\_a_1 = out\_a_0 * in\_a_0) \wedge (out\_a_2 = out\_a_1 * in\_a_0)$\newline
$\phi_b := out\_b_0 = (in\_b_0 * in\_b_0) * in\_b_0$\newline
Чтобы программы были эквивалентны, должно выполняться:\newline
$(in\_a_0 = in\_b_0) \wedge \phi_a \wedge \phi_b \rightarrow out\_a_2 = out\_b_0$
\end{frame}

\begin{frame}{Определения}
\begin{itemize}
\item $at(\phi)$ - множество атомов в формуле $\phi$
\item $at_i(\phi)$ - некоторый заданный порядок этих атомов
\item Атом $a$ сопоставим с булевой переменной $e(a)$ (такую процедуру будем называть булевское кодирование)
\item $e(t)$ - булева формула, полученную булевым кодированием каждого атома формулы $t$ (такую формулу будем называть
пропозиционным скилетом формулы $t$)
\end{itemize}
\end{frame}

\begin{frame}{Пример}
\begin{itemize}
\item $\phi := x = y \vee x = z$
\item $e(x = y) = b_1$
\item $e(x = z) = b_2$
\item $e(\phi) = b_1 \vee b_2$
\end{itemize}
\end{frame}

\begin{frame}{Определения}
\begin{itemize}
\item $\alpha$ - некоторая (возможно, частичная) оценка формулы $e(\phi)$
\item $\alpha = \{e(at_1) \rightarrow FALSE, e(at_2) \rightarrow TRUE\}$
\item $Th(at_i, \alpha) = at_i$, если $\alpha(at_i) = TRUE$, $\lnot at_i$ иначе
\item $Th(\alpha) = \{Th(at_i, \alpha)| для всех e(at_i), оцененных \alpha\}$
\item $\overline{Th(\alpha)}$ - конъюнкция всех элементов их $Th(\alpha)$
\end{itemize}
\end{frame}

\begin{frame}{Ленивый алгоритм решение SMT задач}
Пусть нам данн алгоритм (назовём его $Deduction$), который может решить $\overline{Th(\alpha)}$
\begin{itemize}
\item Вычислим $B = e(\phi)$
\end{itemize}
\end{frame}

\begin{frame}{Ленивый алгоритм решение SMT задач}
Пусть нам данн алгоритм (назовём его $Deduction$), который может решить $\overline{Th(\alpha)}$
\begin{itemize}
\item Вычислим $B = e(\phi)$
\item Отправим $B$ SAT-решателю
\end{itemize}
\end{frame}

\begin{frame}{Ленивый алгоритм решение SMT задач}
Пусть нам данн алгоритм (назовём его $Deduction$), который может решить $\overline{Th(\alpha)}$
\begin{itemize}
\item Вычислим $B = e(\phi)$
\item Отправим $B$ SAT-решателю
\item Если получили "UNSAT", то возвращаем "UNSAT"
\end{itemize}
\end{frame}

\begin{frame}{Ленивый алгоритм решение SMT задач}
Пусть нам данн алгоритм (назовём его $Deduction$), который может решить $\overline{Th(\alpha)}$
\begin{itemize}
\item Вычислим $B = e(\phi)$
\item Отправим $B$ SAT-решателю
\item Если получили "UNSAT", то возвращаем "UNSAT"
\item Если получили "UNKNOWN", то возвращаем "UNKNOWN"
\end{itemize}
\end{frame}

\begin{frame}{Ленивый алгоритм решение SMT задач}
Пусть нам данн алгоритм (назовём его $Deduction$), который может решить $\overline{Th(\alpha)}$
\begin{itemize}
\item Вычислим $B = e(\phi)$
\item Отправим $B$ SAT-решателю
\item Если получили "UNSAT", то возвращаем "UNSAT"
\item Если получили "UNKNOWN", то возвращаем "UNKNOWN"
\item Если получили некоторую $\alpha$, то вычисляем $Deduction$ от $\overline{Th(\alpha)}$
\end{itemize}
\end{frame}

\begin{frame}{Ленивый алгоритм решение SMT задач}
Пусть нам данн алгоритм (назовём его $Deduction$), который может решить $\overline{Th(\alpha)}$
\begin{itemize}
\item Вычислим $B = e(\phi)$
\item Отправим $B$ SAT-решателю
\item Если получили "UNSAT", то возвращаем "UNSAT"
\item Если получили "UNKNOWN", то возвращаем "UNKNOWN"
\item Если получили некоторую $\alpha$, то вычисляем $Deduction$ от $\overline{Th(\alpha)}$
\item Если получили "SAT", то возвращаем "SAT"
\end{itemize}
\end{frame}

\begin{frame}{Ленивый алгоритм решение SMT задач}
Пусть нам данн алгоритм (назовём его $Deduction$), который может решить $\overline{Th(\alpha)}$
\begin{itemize}
\item Вычислим $B = e(\phi)$
\item Отправим $B$ SAT-решателю
\item Если получили "UNSAT", то возвращаем "UNSAT"
\item Если получили "UNKNOWN", то возвращаем "UNKNOWN"
\item Если получили некоторую $\alpha$, то вычисляем $Deduction$ от $\overline{Th(\alpha)}$
\item Если получили "SAT", то возвращаем "SAT"
\item Если получили "UNKNOWN", то возвращаем "UNKNOWN"
\end{itemize}
\end{frame}

\begin{frame}{Ленивый алгоритм решение SMT задач}
Пусть нам данн алгоритм (назовём его $Deduction$), который может решить $\overline{Th(\alpha)}$
\begin{itemize}
\item Вычислим $B = e(\phi)$
\item Отправим $B$ SAT-решателю
\item Если получили "UNSAT", то возвращаем "UNSAT"
\item Если получили "UNKNOWN", то возвращаем "UNKNOWN"
\item Если получили некоторую $\alpha$, то вычисляем $Deduction$ от $\overline{Th(\alpha)}$
\item Если получили "SAT", то возвращаем "SAT"
\item Если получили "UNKNOWN", то возвращаем "UNKNOWN"
\item Если получили "UNSAT", то $B = B \wedge$ "блокирующий дизюнкт" $t$ и начинаем со второго пункта
\end{itemize}
\end{frame}

\begin{frame}{Lazy}
\begin{algorithmic}
\Function{Lazy}{$\phi$}
    \State $B := e(\phi)$
    \While {true}
        \State $<\alpha, res> := SAT-Solver(B)$
        \If {res = <<Unsatisfiable>>}
            \State return <<Unsatisfiable>>;
        \Else
            \State $<t, res> := Deduction(\overline{Th(\alpha)})$
            \If {res = <<Satisfiable>>}
                \State return <<Satisfiable>>
            \EndIf
            \State $B := B \wedge e(t)$;
        \EndIf
    \EndWhile
\EndFunction
\end{algorithmic}
\end{frame}

\begin{frame}{Блокирующий дизюнкт}
Так же называют леммой\newline
Свойства:
\begin{itemize}
\item $t$ - тавтология в $T$
\item $t$ - состоит только из атомов из $\phi$
\item $t$ - "блокирует" $\alpha$, т.е. при отправлении $B$ SAT-решателю мы не сможем снова получить $\alpha$
\end{itemize}
\end{frame}

\begin{frame}{Блокирующий дизюнкт}
Так же называют леммой\newline
Свойства:
\begin{itemize}
\item $t$ - тавтология в $T$
\item $t$ - состоит только из атомов из $\phi$
\item $t$ - "блокирует" $\alpha$, т.е. при отправлении $B$ SAT-решателю мы не сможем снова получить $\alpha$
\end{itemize}
Пример:
\begin{itemize}
\item Пусть $\alpha = \{e(at_1) \rightarrow FALSE, e(at_2) \rightarrow TRUE\}$
\item $t := e(at_1) \vee \lnot e(at_2)$
\end{itemize}
Есть и другие способы найти блокирующий дизюнкт
\end{frame}

\begin{frame}{Ленивый алгоритм решение SMT задач}
\begin{itemize}
\item В процессе работы ленивого алгоритма может возникнуть много блокирующих дизюнктов
\item Многие теории можно свести к SAT задаче, но обычно существуют более эффективные алгоритмы решения теорий
\end{itemize}
\end{frame}

\begin{frame}{Пример}
$x = y \wedge ((y = z \wedge \lnot(x = z)) \vee x = z)$
\end{frame}

\begin{frame}{CDCL}
\begin{algorithmic}
\Function {CDCL}{}
    \While {true}
        \While {BCP() = "conflict"}
            \State backtrack-level := Analyze-Conflict()
            \If {backtrack-level < 0}
                \State return "Unsatisfiable"
            \EndIf
            \State BackTrack(backtrack-level)
            \If {$\lnot$ Decide()}
                \State return "Satisfiable"
            \EndIf
        \EndWhile
    \EndWhile
\EndFunction
\end{algorithmic}
\end{frame}

\begin{frame}
\includegraphics[scale=0.45]{pineapple}
\end{frame}

\begin{frame}
\begin{itemize}
\item Пусть $B_i$ - формула, которая получилась Lazy на $i$-ом шаге
\item По построению, $B_i$ - подформула $B_{i+1}$
\item Давайте не будем заново вызывать SAT решатель, а просто встроем в SAT решатель вызов решателя теории (и после вызова
решателя теорий будем добавлять блокирующий дизъюнкт)
\end{itemize}
\end{frame}

\begin{frame}{Lazy-CDCL(T)}
\begin{algorithmic}
\State AddClauses(cnf(e($\phi$)))
\While {true}
    \While {BCP() = <<conflict>>}
        \State backtrack-level := Analyze-Conflict()
        \If {backtrack-level < 0}
            \State return <<Unsatisfiable>>
        \Else
            \State BackTrack(backtrack-level)
        \EndIf
        \If {$\lnot$ Decide()}
            \State $<t, res> := Deduction(\overline{Th(\alpha)})$
            \If {res = <<Satisfiable>>}
                \State return <<Satisfiable>>
            \EndIf
            \State AddClauses(e(t))
        \EndIf
    \EndWhile
\EndWhile
\end{algorithmic}
\end{frame}

\begin{frame}
\begin{itemize}
\item Что, если уже при данной частичной оценке формула в теории $T$ уже не выполнима?
\item Давайте всегда вызывать Deduction и добавлять к формуле невыолнимое ядро формулы
\end{itemize}
\end{frame}

\begin{frame}{DPLL(T)}
\begin{algorithmic}
\State AddClauses(cnf(e($\phi$)))
\While {true}
    \Repeat
        \While {BCP() = <<conflict>>}
            \State backtrack-level := Analyze-Conflict()
            \If {backtrack-level < 0}
                \State return <<Unsatisfiable>>
            \Else
                \State BackTrack(backtrack-level)
            \EndIf
            \State $<t, res> := Deduction(\overline{Th(\alpha)})$; AddClauses(e(t))
        \EndWhile
    \Until{t = true}
    \If {$\alpha$ is a full assignment}
        \State return <<Satisfiable>>
    \EndIf
    \State Decide()
\EndWhile
\end{algorithmic}
\end{frame}

\begin{frame}
\includegraphics[scale=0.5]{../decision-procedure.png}
\end{frame}

\end{document}
